---
title: 前端笔记-函数防抖和节流
date: 2019-11-01 08:27:55
tags: [javascript]
categories: 前端笔记
---

今天笔记一下函数防抖和节流的理解，和一例在实际工作中，函数防抖的应用。
       首先从字面意思上理解一下防抖和节流，首先说明一下防抖和节流的场景是比较类似的，都是一种大量快速触发的场景中的不同应对策略。
       **防抖**，顾名思义是在防止什么东西，说明我们需求上不需要他“抖”，所以尽可能让他看上去不抖了就好，所以防抖的场景是类似于，比如，页面滚动事件，当滚动开始时，事件监听器就一直不断的回调，这个时候，可能你不想要每次滚动都去执行一些操作，只要第一次发生滚动，告诉我页面开始滚动啦就好，那这时候就应该做防抖处理。
       而**节流**，字面表达是节约什么，也就是说我们不是不需要了，而是不需要那么多那么频繁，这样对我们更方便一些，所以节流，就还是用滚动事件做比方，比如我们在滚动发生的时候，想要每隔几秒钟执行一个操作，并不需要每次监听到滚动都执行，那么这个时候就是节流。

***

那么下面就记录一个工作中使用到防抖的情况，场景接上一篇笔记，需求大致如下：

1.目前我有一个弹出框，显示在界面上，弹出框具有最大化和还原功能，调整窗口大小
2.弹框里面用于显示一个数据列表，带有分页，弹框内部要保证没有滚动条，所以数据需要根据窗口大小动态调整
3.最大最小化的时候使用的过渡动画

所以呢，我现在需要在动画结束后去执行一些操作调整弹窗内部的数据列表，那么就需要获取到最大化或还原完成的时机。

``` bash
function debounce (call) {
    var _call = call;
    var num;
    var store = [];
    return {
        call (data) {
            if (store.length >=20) {
                store.shift();
                store.push(data);
            } else {
                store.push(data);
            }
            let dic = {}
            for (let k in store){
                if (!dic[store[k]]){dic[store[k]] = [k]}
                else{dic[store[k]][1] = k}
            }
            for (let k in dic){if (dic[k].length==1){delete(dic[k])}}
            let keys = Object.keys(dic)
            for (let i = 0; i < keys.length; i++) {
                if (dic[keys[i]][1] - dic[keys[i]][0] >= 19 && num != keys[i]) {
                    _call && _call(keys[i]);
                    num = keys[i];
                }
            }
            
            
        },
        destroy () {
            num = null;
            _call = null;
        }
    }
}
```

思路就是，首先创建一个闭包，并且将我们想要在监听的尺寸变化完成时要执行的函数传入，也就是标橙色的call，然后定义的两个变量，num和store都是用于记录和标识的，主要先指定一个防抖的规则，比如我这里就制定，当输入重复20次一样之后，就认定为一次输入结束了，所以闭包暴露了一个call方法，这个方法就是用于不停输入的，call方法内部虽然有很多判断很多遍历，但是都是用于判断当前是否有连续的20次同样的输入，如果达成这个条件就代表已经取到我们想要的时机了，这个时候执行之前传入的回调函数即可。